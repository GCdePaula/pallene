-- Copyright (c) 2020, The Pallene Developers
-- Pallene is licensed under the MIT license.
-- Please refer to the LICENSE and AUTHORS files for details
-- SPDX-License-Identifier: MIT

local util = require "pallene.util"

--
-- This file implements a Pallene to Lua translator.
--
-- The Pallene compiler is divided into two logical ends:
-- * The frontend which parses Pallene source code to generate AST and performs semantic analysis.
-- * The backend which generates C source code.
--
-- Both these ends are decoupled, this provides us with the flexibility to integrate another backend
-- that generates Lua. The users can run the compiler with `--emit-lua` trigger the translator to
-- generate plain Lua instead of C.
--
-- The generation of Lua is performed by a different backend (implemented here). It accepts input
-- string and the AST generated by the parser. The generator then walks over the AST to replacing
-- type annotations with white space. Interestingly spaces, newlines, comments and pretty much
-- everything else other than type annotations are retained in the translated code. Thus, the
-- formatting in the original input is preserved, which means the error messages always point to
-- the same location in both Pallene and Lua code.
--

local translator = {}

local Translator = util.Class()

function Translator:init()
    self.last_index = 1
    self.partials = {}
    return self
end

function Translator:add_previous(input, stop_index)
    assert(self.last_index <= stop_index + 1)
    local partial = input:sub(self.last_index, stop_index)
    table.insert(self.partials, partial)
    self.last_index = stop_index + 1
end

function Translator:add_whitespace(input, start_index, stop_index)
    assert(self.last_index <= start_index)
    assert(start_index <= stop_index+1)
    self:add_previous(input, start_index - 1)

    local region = input:sub(start_index, stop_index)
    local partial = region:gsub("%S", " ")
    table.insert(self.partials, partial)

    self.last_index = stop_index + 1
end

function translator.translate(input, prog_ast)
    local instance = Translator:new()

    print(require("inspect")(prog_ast))

    for _, node in ipairs(prog_ast) do
        if node._tag == "ast.Toplevel.Var" then
            for _, decl in ipairs(node.decls) do
                if decl.type then
                    -- Remove the colon but retain any adjacent comment to the right.
                    instance:add_whitespace(input, decl.col_loc.pos, decl.col_loc.pos)
                    -- Remove the type annotation but exclude the next token.
                    instance:add_whitespace(input, decl.type.loc.pos, decl.end_loc.pos - 1)
                end
            end
        elseif node._tag == "ast.Toplevel.Func" then
            -- Remove type annotations from function parameters.
            for _, arg_decl in ipairs(node.value.arg_decls) do
                -- Type annotations are mandatory for function parameters.
                -- Remove the colon but retain any adjacent comment to the right.
                instance:add_whitespace(input, arg_decl.col_loc.pos, arg_decl.col_loc.pos)
                -- Remove the type annotation but exclude the next token.
                instance:add_whitespace(input, arg_decl.type.loc.pos, arg_decl.end_loc.pos - 1)
            end

            -- Remove type annotations from the return type, which is optional. However, `rt_col_loc`
            -- and `rt_end_loc` are always set. Therefore, it is safe to replace without any checks.
            instance:add_whitespace(input, node.rt_col_loc.pos, node.rt_end_loc.pos - 1)

            -- Remove type annotations from local declarations.
            for _, statement in ipairs(node.value.body.stats) do
                if statement._tag == "ast.Stat.Decl" then
                    for _, decl in ipairs(statement.decls) do
                        if decl.type then
                            -- Remove the colon but retain any adjacent comment to the right.
                            instance:add_whitespace(input, decl.col_loc.pos, decl.col_loc.pos)
                            -- Remove the type annotation but exclude the next token.
                            instance:add_whitespace(input, decl.type.loc.pos, decl.end_loc.pos - 1)
                        end
                    end
                end
            end
        elseif node._tag == "ast.Toplevel.Typealias" then
            -- Remove the type alias but exclude the next token.
            instance:add_whitespace(input, node.loc.pos, node.end_loc.pos - 1)
        elseif node._tag == "ast.Toplevel.Record" then
            -- Remove the record but exclude the next token.
            instance:add_whitespace(input, node.loc.pos, node.end_loc.pos - 1)
        end
    end
    -- Whatever characters that were not included in the partials should be added.
    instance:add_previous(input, #input)

    return table.concat(instance.partials, "")
end

return translator
