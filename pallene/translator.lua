-- Copyright (c) 2020, The Pallene Developers
-- Pallene is licensed under the MIT license.
-- Please refer to the LICENSE and AUTHORS files for details
-- SPDX-License-Identifier: MIT

local util = require "pallene.util"

--
-- This file implements a Pallene to Lua translator.
--
-- The Pallene compiler is divided into two logical ends:
-- * The frontend which parses Pallene source code to generate AST and performs semantic analysis.
-- * The backend which generates C source code.
--
-- Both these ends are decoupled, this provides us with the flexibility to integrate another backend
-- that generates Lua. The users can run the compiler with `--emit-lua` trigger the translator to
-- generate plain Lua instead of C.
--
-- The generation of Lua is performed by a different backend (implemented here). It accepts input
-- string and the AST generated by the parser. The generator then walks over the AST to replacing
-- type annotations with white space. Interestingly spaces, newlines, comments and pretty much
-- everything else other than type annotations are retained in the translated code. Thus, the
-- formatting in the original input is preserved, which means the error messages always point to
-- the same location in both Pallene and Lua code.
--
-- Since shadowing top-level components is a syntax error in Pallene, the translator can generate
-- all the forward references at the beginning of the module. This design allows us to not worry
-- about finding empty lines, lines with comments, and so on to correctly translate mutually recursive
-- function groups.
--

local translator = {}

local Translator = util.Class()

function Translator:init(input)
    self.input = input -- string
    self.last_index = 1 -- integer
    self.partials = {} -- list of strings
    self.exports = {} -- list of strings
    return self
end

function Translator:add_previous(stop_index)
    assert(self.last_index <= stop_index + 1)
    local partial = self.input:sub(self.last_index, stop_index)
    table.insert(self.partials, partial)
    self.last_index = stop_index + 1
end

function Translator:add_whitespace(start_index, stop_index)
    assert(self.last_index <= start_index)
    assert(start_index <= stop_index + 1)
    self:add_previous(start_index - 1)

    local region = self.input:sub(start_index, stop_index)
    local start_pos = region:find("[\n\r][ \t]*$")
    if start_pos then
        local first_region = region:sub(1, start_pos)
        local first_partial = first_region:gsub("[^\n\r]", "")
        local last_partial = region:sub(start_pos + 1)

        table.insert(self.partials, first_partial)
        table.insert(self.partials, last_partial)
    else
        local partial = region:gsub("[^\n\r]", "")
        table.insert(self.partials, partial)
    end

    if self.input:sub(stop_index + 1, stop_index + 1) == "=" then
        table.insert(self.partials, " ")
    end

    self.last_index = stop_index + 1
end

function Translator:add_local(start_index)
    self:add_previous(start_index - 1)
    -- The export keyword is six characters long, whereas the local keyword is five characters
    -- long. Therefore, we pad the keyword with a space. We could add the space to the left, too.
    -- But it seems more "natural" on the right.
    table.insert(self.partials, "local ")

    self.last_index = self.last_index + 6
end

function Translator:add_exports()
    if #self.exports > 0 then
        table.insert(self.partials, "\nreturn {\n")
        for _, export in ipairs(self.exports) do
            local pair = string.format("    %s = %s,\n", export, export)
            table.insert(self.partials, pair)
        end
        table.insert(self.partials, "}\n")
    end
end

function Translator:translate_decl(decl)
    if decl.col_loc then
        self:add_whitespace(decl.col_loc.pos, decl.end_loc.pos - 1)
    end
end

function Translator:translate_var(var)
    local tag = var._tag
    if tag == "ast.Var.Name" then
        -- Nothing
    elseif tag == "ast.Var.Bracket" then
        self:translate_exp(var.t)
        self:translate_exp(var.k)
    elseif tag == "ast.Var.Dot" then
        self:translate_exp(var.exp)
    else
        error("impossible")
    end
end

function Translator:translate_exp(exp)
    local tag = exp._tag

    if tag == "ast.Exp.Nil" or tag == "ast.Exp.Bool" or tag == "ast.Exp.Integer" or
        tag == "ast.Exp.Float" or tag == "ast.Exp.String" then
        -- Nothing
    elseif tag == "ast.Exp.Initlist" then
        for _, field in ipairs(exp.fields) do
            self:translate_field(field)
        end
    elseif tag == "ast.Exp.Lambda" then
        error("not implemented")
    elseif tag == "ast.Exp.CallFunc" then
        self:translate_exp(exp.exp)
        for _, arg in ipairs(exp.args) do
            self:translate_exp(arg)
        end
    elseif tag == "ast.Exp.CallMethod" then
        error("not implemented")
    elseif tag == "ast.Exp.Var" then
        self:translate_var(exp.var)
    elseif tag == "ast.Exp.Unop" then
        self:translate_exp(exp.exp)
    elseif tag == "ast.Exp.Concat" then
        for _, inner_exp in ipairs(exp.exps) do
            self:translate_exp(inner_exp)
        end
    elseif tag == "ast.Exp.Binop" then
        self:translate_exp(exp.lhs)
        self:translate_exp(exp.rhs)
    elseif tag == "ast.Exp.Cast" then
        self:translate_exp(exp.exp)
        if exp.target then
            self:add_whitespace(exp.loc.pos, exp.target_end_loc.pos - 1)
        end
    elseif tag == "ast.Exp.Paren" then
        self:translate_exp(exp.exp)
    elseif tag == "ast.Exp.ExtraRet" then
        -- Since `ExtraRet` is imaginary, we ignore it.
    elseif tag == "ast.Exp.ToFloat" then
        self:translate_exp(exp.exp)
    else
        error(tag .. " impossible")
    end
end

function Translator:translate_field(field)
    local tag = field._tag
    if tag == "ast.Field.List" then
        self:translate_exp(field.exp)
    elseif tag == "ast.Field.Rec" then
        self:translate_exp(field.exp)
    else
        error("impossible")
    end
end

function Translator:translate_stat(stat)
    if stat._tag == "ast.Stat.Block" then
        for _, s in ipairs(stat.stats) do
            self:translate_stat(s)
        end
    elseif stat._tag == "ast.Stat.While" then
        self:translate_exp(stat.condition)
        self:translate_stat(stat.block)
    elseif stat._tag == "ast.Stat.Repeat" then
        self:translate_stat(stat.block)
        self:translate_exp(stat.condition)
    elseif stat._tag == "ast.Stat.If" then
        self:translate_exp(stat.condition)
        self:translate_stat(stat.then_)
        self:translate_stat(stat.else_)
    elseif stat._tag == "ast.Stat.For" then
        self:translate_decl(stat.decl)
        self:translate_exp(stat.start)
        self:translate_exp(stat.limit)
        if stat.step then
            self:translate_exp(stat.step)
        end
        self:translate_stat(stat.block)
    elseif stat._tag == "ast.Stat.Assign" then
        for _, exp in ipairs(stat.exps) do
            self:translate_exp(exp)
        end
    elseif stat._tag == "ast.Stat.Decl" then
        for _, decl in ipairs(stat.decls) do
            self:translate_decl(decl)
        end

        for _, exp in ipairs(stat.exps) do
            self:translate_exp(exp)
        end
    elseif stat._tag == "ast.Stat.Call" then
        self:translate_exp(stat.call_exp)
    elseif stat._tag == "ast.Stat.Return" then
        for _, exp in ipairs(stat.exps) do
            self:translate_exp(exp)
        end
    elseif stat._tag == "ast.Stat.Break" then
        -- Nothing
    else
        error("impossible")
    end
end

function Translator:erase_mrf_modifier(start_index, visibility)
    self:add_previous(start_index - 1)

    print("!$!", string.sub(self.input, self.last_index, 10))
    if visibility == "local" then
        self.last_index = assert(string.match(self.input, "^local()", self.last_index)) + 1
    elseif visibility == "export" then
        self.last_index = assert(string.match(self.input, "^export()", self.last_index)) + 1
    else
        error("impossible")
    end
end

function Translator:translate_toplevel(node)
    if node._tag == "ast.Toplevel.Var" then
        -- Add the variables to the export sequence if they are declared with the `export`
        -- modifier.
        if node.visibility == "export" then
            self:add_local(node.loc.pos)
            for _, decl in ipairs(node.decls) do
                table.insert(self.exports, decl.name)
            end
        end

        for _, decl in ipairs(node.decls) do
            self:translate_decl(decl)
        end

        for _, value in ipairs(node.values) do
            self:translate_exp(value)
        end
    elseif node._tag == "ast.Toplevel.Func" then
        self:erase_mrf_modifier(node.loc.pos, node.visibility)
        -- The semicolon tokens ensures that the previous token is not touched by the `local` keyword.
        -- Also, we do not have to append a space character because the modifier is always followed
        -- by a whitespace.
        local name = node.decl.name

        if node.visibility == "export" then
            table.insert(self.exports, name)
        end

        -- Remove type annotations from function parameters.
        for _, arg_decl in ipairs(node.value.arg_decls) do
            self:translate_decl(arg_decl)
        end

        -- Remove type annotations from the return type, which is optional. However, `rt_col_loc`
        -- and `rt_end_loc` are always set. Therefore, it is safe to replace without any checks.
        self:add_whitespace(node.rt_col_loc.pos, node.rt_end_loc.pos - 1)

        self:translate_stat(node.value.body)
    elseif node._tag == "ast.Toplevel.Typealias" then
        -- Remove the type alias but exclude the next token.
        self:add_whitespace(node.loc.pos, node.end_loc.pos - 1)
    elseif node._tag == "ast.Toplevel.Record" then
        -- Remove the record but exclude the next token.
        self:add_whitespace(node.loc.pos, node.end_loc.pos - 1)
    end
end

function Translator:add_forward_declarations(prog_ast)
    table.insert(self.partials, "local string_ = string;")

    local functions = {}
    for _, node in ipairs(prog_ast) do
        if node._tag == "ast.Toplevel.Func" then
            table.insert(functions, node.decl.name)
        end
    end

    if #functions > 0 then
        table.insert(self.partials, "local ")
        table.insert(self.partials, table.concat(functions, ", "))
        table.insert(self.partials, ";")
    end
end

function translator.translate(input, prog_ast)
    local instance = Translator.new(input)

    instance:add_forward_declarations(prog_ast)
    for _, node in ipairs(prog_ast) do
        instance:translate_toplevel(node)
    end
    -- Whatever characters that were not included in the partials should be added.
    instance:add_previous(#input)
    instance:add_exports()

    return table.concat(instance.partials)
end

return translator
