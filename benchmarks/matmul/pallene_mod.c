/* This file was generated by the Pallene compiler. Do not edit by hand" */
/* Indentation and formatting courtesy of pallene/C.lua */

#include "pallene_core.h"

/* ------- */
/* Records */
/* ------- */

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static Table * function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    Table *x1, /* A */
    Table *x2  /* B */
);

/* ------------------------ */
/* Function Implementations */
/* ------------------------ */

/* $init */
static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    	
}

/* matmul benchmarks/matmul/pallene.pln:1 */
static Table * function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    Table *x1, /* A */
    Table *x2  /* B */
) {
    luaD_checkstack(L, 2);
    Table *x3; /* C */
    lua_Integer x4; /* NI */
    lua_Integer x5; /* NK */
    lua_Integer x6; /* NJ */
    lua_Integer x7; /* i */
    Table *x8; /* line */
    lua_Integer x9; /* j */
    lua_Integer x10; /* k */
    Table *x11; /* Bk */
    lua_Integer x12; /* i */
    lua_Number x13; /* Aik */
    Table *x14; /* Ci */
    lua_Integer x15; /* j */
    Table *x16;
    Table *x17;
    lua_Number x18;
    lua_Number x19;
    lua_Number x20;
    lua_Number x21;
    	
    x3 = pallene_createtable(L, 0, 0);
    sethvalue(L, s2v(base + 0), x3);
    luaC_condGC(L, L->top = base + 1, (void)0);
    if (x1->metatable) {
        pallene_runtime_array_metatable_error(L, 3);
    }
    x4 = luaH_getn(x1);
    if (x2->metatable) {
        pallene_runtime_array_metatable_error(L, 4);
    }
    x5 = luaH_getn(x2);
    {
        pallene_renormalize_array(L, x2, 1, 5);
        TValue *slot = &x2->array[1 - 1];
        if (PALLENE_UNLIKELY(!ttistable(slot))) {
            pallene_runtime_tag_check_error(L,
                5, LUA_TTABLE, rawtt(slot),
                "array element");
        }
        x16 = hvalue(slot);
    }
    if (x16->metatable) {
        pallene_runtime_array_metatable_error(L, 5);
    }
    x6 = luaH_getn(x16);
    // for hoist
    pallene_renormalize_array(L, x3, x4, 11);
    PALLENE_INT_FOR_LOOP_BEGIN(x7, 1, x4, 1)
    {
        x8 = pallene_createtable(L, 0, 0);
        sethvalue(L, s2v(base + 1), x8);
        luaC_condGC(L, L->top = base + 2, (void)0);
        // for hoist
        pallene_renormalize_array(L, x8, x6, 9);
        PALLENE_INT_FOR_LOOP_BEGIN(x9, 1, x6, 1)
        {
            {
                TValue *slot = &x8->array[x9 - 1];
                setfltvalue(slot, 0.0);
            }
        }
        PALLENE_INT_FOR_LOOP_END
        {
            TValue *slot = &x3->array[x7 - 1];
            sethvalue(L, slot, x8);
            pallene_barrierback_collectable_child(L, x3, x8);
        }
    }
    PALLENE_INT_FOR_LOOP_END
    // for hoist
    pallene_renormalize_array(L, x2, x5, 14);
    //const hoist
    pallene_renormalize_array(L, x1, x4, 16);
    PALLENE_INT_FOR_LOOP_BEGIN(x10, 1, x5, 1)
    {
        {
            TValue *slot = &x2->array[x10 - 1];
            if (PALLENE_UNLIKELY(!ttistable(slot))) {
                pallene_runtime_tag_check_error(L,
                    14, LUA_TTABLE, rawtt(slot),
                    "array element");
            }
            x11 = hvalue(slot);
        }
        //for hoist
        //pallene_renormalize_array(L, x1, x4, 16);
        PALLENE_INT_FOR_LOOP_BEGIN(x12, 1, x4, 1)
        {
            {
                //pallene_renormalize_array(L, x1, x12, 16);
                TValue *slot = &x1->array[x12 - 1];
                if (PALLENE_UNLIKELY(!ttistable(slot))) {
                    pallene_runtime_tag_check_error(L,
                        16, LUA_TTABLE, rawtt(slot),
                        "array element");
                }
                x17 = hvalue(slot);
            }
            {
                pallene_renormalize_array(L, x17, x10, 16);
                TValue *slot = &x17->array[x10 - 1];
                if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                    pallene_runtime_tag_check_error(L,
                        16, LUA_TNUMFLT, rawtt(slot),
                        "array element");
                }
                x13 = fltvalue(slot);
            }
            {
                pallene_renormalize_array(L, x3, x12, 17);
                TValue *slot = &x3->array[x12 - 1];
                if (PALLENE_UNLIKELY(!ttistable(slot))) {
                    pallene_runtime_tag_check_error(L,
                        17, LUA_TTABLE, rawtt(slot),
                        "array element");
                }
                x14 = hvalue(slot);
            }
            // for hoist
            pallene_renormalize_array(L, x14, x6, 19);
            PALLENE_INT_FOR_LOOP_BEGIN(x15, 1, x6, 1)
            {
                TValue *slot1 = &x14->array[x15 - 1];
                {
                    
                    if (PALLENE_UNLIKELY(!ttisfloat(slot1))) {
                        pallene_runtime_tag_check_error(L,
                            19, LUA_TNUMFLT, rawtt(slot1),
                            "array element");
                    }
                    x19 = fltvalue(slot1);
                }
                {
                    pallene_renormalize_array(L, x11, x15, 19);
                    TValue *slot = &x11->array[x15 - 1];
                    if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                        pallene_runtime_tag_check_error(L,
                            19, LUA_TNUMFLT, rawtt(slot),
                            "array element");
                    }
                    x21 = fltvalue(slot);
                }
                x20 = x13 * x21;
                x18 = x19 + x20;
                {
                    //pallene_renormalize_array(L, x14, x15, 19);
                    //TValue *slot = &x14->array[x15 - 1];
                    //reuse slot from above 
                    setfltvalue(slot1, x18);
                }
            }
            PALLENE_INT_FOR_LOOP_END
        }
        PALLENE_INT_FOR_LOOP_END
    }
    PALLENE_INT_FOR_LOOP_END
    return x3;
}

/* ------- */
/* Exports */
/* ------- */

static int function_01_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "$init", 0, nargs);
    }
    	
    function_01(L, G, L->top);
    return 0;
}

static int function_02_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 2)) {
        pallene_runtime_arity_error(L, "matmul", 2, nargs);
    }
    	
    Table *x1;
    Table *x2;
    	
    if (PALLENE_UNLIKELY(!ttistable(s2v(base + 1)))) {
        pallene_runtime_tag_check_error(L,
            1, LUA_TTABLE, rawtt(s2v(base + 1)),
            "argument '%s'", "A");
    }
    x1 = hvalue(s2v(base + 1));
    	
    if (PALLENE_UNLIKELY(!ttistable(s2v(base + 2)))) {
        pallene_runtime_tag_check_error(L,
            1, LUA_TTABLE, rawtt(s2v(base + 2)),
            "argument '%s'", "B");
    }
    x2 = hvalue(s2v(base + 2));
    	
    Table *ret1;
    ret1 = function_02(L, G, L->top, x1, x2);
    sethvalue(L, s2v(L->top), ret1);
    L->top++;
    return 1;
}

int luaopen_benchmarks_matmul_pallene_mod(lua_State *L)
{
    luaL_checkversion(L);
    	
    lua_newuserdatauv(L, 0, 0);
    int globals = lua_gettop(L);
    	
    lua_createtable(L, 2, 0);
    int closures = lua_gettop(L);
    	
    lua_newtable(L);
    int export_table = lua_gettop(L);
    	
    /* Closures */
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_01_lua, 1);
    lua_seti(L, closures, 1);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_02_lua, 1);
    lua_seti(L, closures, 2);
    	
    /* Global values */
    	
    // Run toplevel statements & initialize globals
    lua_geti(L, closures, 1);
    lua_call(L, 0, 0);
    	
    /* Exports */
    	
    lua_pushstring(L, "matmul");
    lua_geti(L, closures, 2);
    lua_settable(L, export_table);
    	
    lua_pushvalue(L, export_table);
    return 1;
}

