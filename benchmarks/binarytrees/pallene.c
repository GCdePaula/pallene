/* This file was generated by the Pallene compiler. Do not edit by hand" */
/* Indentation and formatting courtesy of pallene/C.lua */

#include "pallene_core.h"

/* ------- */
/* Records */
/* ------- */

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static Table * function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1  /* depth */
);
static lua_Integer function_03(
    lua_State *L,
    Udata *G,
    StackValue *base,
    Table *x1  /* tree */
);
static Table * function_04(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* mindepth */
    lua_Integer x2, /* maxdepth */
    lua_Integer x3  /* depth */
);

/* ------------------------ */
/* Function Implementations */
/* ------------------------ */

/* $init */
static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    	
}

/* BottomUpTree benchmarks/binarytrees/pallene.pln:1 */
static Table * function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1  /* depth */
) {
    luaD_checkstack(L, 3);
    Table *x2; /* left */
    Table *x3; /* right */
    int x4;
    Table *x5;
    TValue x6;
    TValue x7;
    Table *x8;
    TValue x9;
    TValue x10;
    	
    x4 = (x1 > 0);
    if (x4) {
        x1 = intop(-, x1, 1);
        {
            StackValue *old_stack = L->stack;
            x2 = function_02(L, G, base + 0, x1);
            base = L->stack + (base - old_stack);
        }
        sethvalue(L, s2v(base + 0), x2);
        {
            StackValue *old_stack = L->stack;
            x3 = function_02(L, G, base + 1, x1);
            base = L->stack + (base - old_stack);
        }
        sethvalue(L, s2v(base + 1), x3);
        x5 = pallene_createtable(L, 2, 0);
        sethvalue(L, s2v(base + 2), x5);
        luaC_condGC(L, L->top = base + 3, (void)0);
        sethvalue(L, &x6, x2);
        {
            pallene_renormalize_array(L, x5, 1, 6);
            TValue *slot = &x5->array[1 - 1];
            setobj(L, slot, &x6);
            pallene_barrierback_unknown_child(L, x5, &x6);
        }
        sethvalue(L, &x7, x3);
        {
            pallene_renormalize_array(L, x5, 2, 6);
            TValue *slot = &x5->array[2 - 1];
            setobj(L, slot, &x7);
            pallene_barrierback_unknown_child(L, x5, &x7);
        }
        return x5;
    } else {
        x8 = pallene_createtable(L, 2, 0);
        sethvalue(L, s2v(base + 0), x8);
        luaC_condGC(L, L->top = base + 1, (void)0);
        setbvalue(&x9, 0);
        {
            pallene_renormalize_array(L, x8, 1, 8);
            TValue *slot = &x8->array[1 - 1];
            setobj(L, slot, &x9);
            pallene_barrierback_unknown_child(L, x8, &x9);
        }
        setbvalue(&x10, 0);
        {
            pallene_renormalize_array(L, x8, 2, 8);
            TValue *slot = &x8->array[2 - 1];
            setobj(L, slot, &x10);
            pallene_barrierback_unknown_child(L, x8, &x10);
        }
        return x8;
    }
}

/* ItemCheck benchmarks/binarytrees/pallene.pln:12 */
static lua_Integer function_03(
    lua_State *L,
    Udata *G,
    StackValue *base,
    Table *x1  /* tree */
) {
    luaD_checkstack(L, 1);
    TValue x2;
    int x3;
    lua_Integer x4;
    lua_Integer x5;
    lua_Integer x6;
    Table *x7;
    TValue x8;
    lua_Integer x9;
    Table *x10;
    TValue x11;
    	
    {
        pallene_renormalize_array(L, x1, 1, 13);
        TValue *slot = &x1->array[1 - 1];
        x2 = *(slot);
        if (isempty(slot)) {
            if (x1->metatable) {
                pallene_runtime_array_metatable_error(L, 13);
            }
        }
        if (isempty(slot)) {
            setnilvalue(&x2);
        }
    }
    x3 = pallene_is_truthy(&x2);
    if (x3) {
        {
            pallene_renormalize_array(L, x1, 1, 14);
            TValue *slot = &x1->array[1 - 1];
            x8 = *(slot);
            if (isempty(slot)) {
                if (x1->metatable) {
                    pallene_runtime_array_metatable_error(L, 14);
                }
            }
            if (isempty(slot)) {
                setnilvalue(&x8);
            }
        }
        if (PALLENE_UNLIKELY(!ttistable(&x8))) {
            pallene_runtime_tag_check_error(L,
                14, LUA_TTABLE, rawtt(&x8),
                "downcasted value");
        }
        x7 = hvalue(&x8);
        sethvalue(L, s2v(base + 0), x7);
        {
            StackValue *old_stack = L->stack;
            x6 = function_03(L, G, base + 1, x7);
            base = L->stack + (base - old_stack);
        }
        x5 = intop(+, 1, x6);
        {
            pallene_renormalize_array(L, x1, 2, 14);
            TValue *slot = &x1->array[2 - 1];
            x11 = *(slot);
            if (isempty(slot)) {
                if (x1->metatable) {
                    pallene_runtime_array_metatable_error(L, 14);
                }
            }
            if (isempty(slot)) {
                setnilvalue(&x11);
            }
        }
        if (PALLENE_UNLIKELY(!ttistable(&x11))) {
            pallene_runtime_tag_check_error(L,
                14, LUA_TTABLE, rawtt(&x11),
                "downcasted value");
        }
        x10 = hvalue(&x11);
        sethvalue(L, s2v(base + 0), x10);
        {
            StackValue *old_stack = L->stack;
            x9 = function_03(L, G, base + 1, x10);
            base = L->stack + (base - old_stack);
        }
        x4 = intop(+, x5, x9);
        return x4;
    } else {
        return 1;
    }
}

/* Stress benchmarks/binarytrees/pallene.pln:20 */
static Table * function_04(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* mindepth */
    lua_Integer x2, /* maxdepth */
    lua_Integer x3  /* depth */
) {
    luaD_checkstack(L, 1);
    lua_Integer x4; /* iterations */
    lua_Integer x5; /* check */
    lua_Integer x6; /* _ */
    Table *x7; /* t */
    lua_Integer x8;
    lua_Integer x9;
    lua_Integer x10;
    Table *x11;
    	
    x9 = intop(-, x2, x3);
    x8 = intop(+, x9, x1);
    x4 = pallene_shiftL(1, x8);
    x5 = 0;
    PALLENE_INT_FOR_LOOP_BEGIN(x6, 1, x4, 1)
    {
        {
            StackValue *old_stack = L->stack;
            x7 = function_02(L, G, base + 0, x3);
            base = L->stack + (base - old_stack);
        }
        sethvalue(L, s2v(base + 0), x7);
        {
            StackValue *old_stack = L->stack;
            x10 = function_03(L, G, base + 1, x7);
            base = L->stack + (base - old_stack);
        }
        x5 = intop(+, x5, x10);
    }
    PALLENE_INT_FOR_LOOP_END
    x11 = pallene_createtable(L, 2, 0);
    sethvalue(L, s2v(base + 0), x11);
    luaC_condGC(L, L->top = base + 1, (void)0);
    {
        pallene_renormalize_array(L, x11, 1, 27);
        TValue *slot = &x11->array[1 - 1];
        setivalue(slot, x4);
    }
    {
        pallene_renormalize_array(L, x11, 2, 27);
        TValue *slot = &x11->array[2 - 1];
        setivalue(slot, x5);
    }
    return x11;
}

/* ------- */
/* Exports */
/* ------- */

static int function_01_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "$init", 0, nargs);
    }
    	
    function_01(L, G, L->top);
    return 0;
}

static int function_02_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 1)) {
        pallene_runtime_arity_error(L, "BottomUpTree", 1, nargs);
    }
    	
    lua_Integer x1;
    	
    if (PALLENE_UNLIKELY(!ttisinteger(s2v(base + 1)))) {
        pallene_runtime_tag_check_error(L,
            1, LUA_TNUMINT, rawtt(s2v(base + 1)),
            "argument '%s'", "depth");
    }
    x1 = ivalue(s2v(base + 1));
    	
    Table *ret1;
    ret1 = function_02(L, G, L->top, x1);
    sethvalue(L, s2v(L->top), ret1);
    L->top++;
    return 1;
}

static int function_03_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 1)) {
        pallene_runtime_arity_error(L, "ItemCheck", 1, nargs);
    }
    	
    Table *x1;
    	
    if (PALLENE_UNLIKELY(!ttistable(s2v(base + 1)))) {
        pallene_runtime_tag_check_error(L,
            12, LUA_TTABLE, rawtt(s2v(base + 1)),
            "argument '%s'", "tree");
    }
    x1 = hvalue(s2v(base + 1));
    	
    lua_Integer ret1;
    ret1 = function_03(L, G, L->top, x1);
    setivalue(s2v(L->top), ret1);
    L->top++;
    return 1;
}

static int function_04_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 3)) {
        pallene_runtime_arity_error(L, "Stress", 3, nargs);
    }
    	
    lua_Integer x1;
    lua_Integer x2;
    lua_Integer x3;
    	
    if (PALLENE_UNLIKELY(!ttisinteger(s2v(base + 1)))) {
        pallene_runtime_tag_check_error(L,
            20, LUA_TNUMINT, rawtt(s2v(base + 1)),
            "argument '%s'", "mindepth");
    }
    x1 = ivalue(s2v(base + 1));
    	
    if (PALLENE_UNLIKELY(!ttisinteger(s2v(base + 2)))) {
        pallene_runtime_tag_check_error(L,
            20, LUA_TNUMINT, rawtt(s2v(base + 2)),
            "argument '%s'", "maxdepth");
    }
    x2 = ivalue(s2v(base + 2));
    	
    if (PALLENE_UNLIKELY(!ttisinteger(s2v(base + 3)))) {
        pallene_runtime_tag_check_error(L,
            20, LUA_TNUMINT, rawtt(s2v(base + 3)),
            "argument '%s'", "depth");
    }
    x3 = ivalue(s2v(base + 3));
    	
    Table *ret1;
    ret1 = function_04(L, G, L->top, x1, x2, x3);
    sethvalue(L, s2v(L->top), ret1);
    L->top++;
    return 1;
}

int luaopen_benchmarks_binarytrees_pallene(lua_State *L)
{
    luaL_checkversion(L);
    	
    lua_newuserdatauv(L, 0, 0);
    int globals = lua_gettop(L);
    	
    lua_createtable(L, 4, 0);
    int closures = lua_gettop(L);
    	
    lua_newtable(L);
    int export_table = lua_gettop(L);
    	
    /* Closures */
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_01_lua, 1);
    lua_seti(L, closures, 1);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_02_lua, 1);
    lua_seti(L, closures, 2);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_03_lua, 1);
    lua_seti(L, closures, 3);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_04_lua, 1);
    lua_seti(L, closures, 4);
    	
    /* Global values */
    	
    // Run toplevel statements & initialize globals
    lua_geti(L, closures, 1);
    lua_call(L, 0, 0);
    	
    /* Exports */
    	
    lua_pushstring(L, "BottomUpTree");
    lua_geti(L, closures, 2);
    lua_settable(L, export_table);
    	
    lua_pushstring(L, "ItemCheck");
    lua_geti(L, closures, 3);
    lua_settable(L, export_table);
    	
    lua_pushstring(L, "Stress");
    lua_geti(L, closures, 4);
    lua_settable(L, export_table);
    	
    lua_pushvalue(L, export_table);
    return 1;
}

