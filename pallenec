#!/usr/bin/env lua

local argparse = require "argparse"
local inspect = require "inspect"

local driver = require "pallene.driver"
local print_ir = require "pallene.print_ir"
local util = require "pallene.util"
local Lexer = require "pallene.Lexer"

--
-- Command-line options
--

local p = argparse("pallenec", "Pallene compiler")
p:argument("source_file", "File to compile")

-- What the compiler should output.
p:mutex(
    p:flag("--emit-c",    "Generate a .c file instead of an .so file"),
    p:flag("--emit-asm",  "Generate a .s file instead of an .so file"),
    p:flag("--emit-lua",  "Generate a .lua file instead of an .so file"),
    p:flag("--compile-c", "Compile a .c file generated by --emit-c"),
    p:flag("--print-ir",  "Print a human-readable version of the program's IR"),
    p:flag("--tokens", "Print the tokens recognized by the lexer"),
    p:option("--dump", "Print the result of an internal compiler pass")
        :choices(driver.list_of_compiler_passes)
)

-- Optimization levels for the Pallene and C compiler. (-O0 disables optimizations for both)
-- NOTE: *For C compiler only* this option may be overridden  using the CFLAGS environment variable.
p:option("-O", "Optimization level")
    :args(1):convert(tonumber)
    :choices({0, 1, 2, 3})
    :default(2)


local args = p:parse()

local opt_level = args.O

-- For compilation errors that don't happen inside a source file.
-- Inspired by gcc, eg. "gcc: fatal error: no input files".
local compiler_name = arg[0]

local function compile(in_ext, out_ext)
    local ok, errs = driver.compile(compiler_name, in_ext, out_ext, args.source_file, opt_level)
    if not ok then util.abort(table.concat(errs, "\n")) end
end

local inspect_opts = {
    process = function(item, path)
        local key = path[#path]
        if key == inspect.METATABLE then
            return nil
        elseif type(key) == "string" and (key == "loc" or string.match(key, "_loc$")) then
            if args.show_locations then
                return item and string.format("%d:%d", item.line, item.col)
            else
                return nil
            end
        else
            return item
        end
    end
}

local function dump(filename, stop_after)
    local input, err = driver.load_input(filename)
    if err then util.abort(err) end

    local out, errs = driver.compile_internal(filename, input, stop_after, opt_level)
    if not out then util.abort(table.concat(errs, "\n")) end

    print(inspect(out, inspect_opts))
    print(string.format("Exit after %s step", stop_after))
end

local function print_tokens(file_name)
    local input, err = driver.load_input(file_name)
    if input then
        local lexer = Lexer.new(file_name, input)
        local token = lexer:next()
        print(string.format("<%s>", file_name))
        while token.name ~= "EOF" do
            local loc = token.loc
            local end_loc = token.end_loc
            local value = ""
            if token.value then
                value = string.format(" (%s)", token.value)
            end
            local s = string.format("%d:%d,%d:%d,%d:%d %s%s", loc.line, loc.col,
                end_loc.line, end_loc.col, loc.pos, end_loc.pos, token.name, value)
            print(s)
            token = lexer:next()
        end
    else
        print("error: " .. err)
    end
end

local function pretty_print_ir(filename)
    local input, err = driver.load_input(filename)
    if not input then util.abort(err) end

    local module, errs = driver.compile_internal(filename, input, "ir")
    if not module then util.abort(table.concat(errs, "\n")) end

    io.stdout:write(print_ir(module))
end

if     args.emit_c    then compile("pln", "c")
elseif args.emit_asm  then compile("c",   "s")
elseif args.compile_c then compile("c" ,  "so")
elseif args.dump      then dump(args.source_file, args.dump)
elseif args.tokens    then print_tokens(args.source_file)
elseif args.print_ir  then pretty_print_ir(args.source_file)
elseif args.emit_lua  then compile("pln", "lua")
else                       compile("pln", "so")
end
