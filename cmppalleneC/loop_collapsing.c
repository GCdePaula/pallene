/* This file was generated by the Pallene compiler. Do not edit by hand" */
/* Indentation and formatting courtesy of pallene/C.lua */

#include "pallene_core.h"

/* ------- */
/* Records */
/* ------- */

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static void function_02(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static void function_03(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static void function_04(
    lua_State *L,
    Udata *G,
    StackValue *base
);

/* ------------------------ */
/* Function Implementations */
/* ------------------------ */

/* $init */
static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    luaD_checkstack(L, 1);
    Table *x1;
    	
    x1 = pallene_createtable(L, 0, 0);
    sethvalue(L, s2v(base + 0), x1);
    luaC_condGC(L, L->top = base + 1, (void)0);
    sethvalue(L, &G->uv[0].uv, x1);
    pallene_barrierback_collectable_child(L, G, x1);
}

/* simple cmppalleneC/loop_collapsing.pln:3 */
static void function_02(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    lua_Integer x1; /* x */
    lua_Integer x2; /* i */
    lua_Integer x3; /* j */
    	
    x1 = 0;
    PALLENE_INT_FOR_LOOP_BEGIN(x2, 0, 300, 1)
    {
        PALLENE_INT_FOR_LOOP_BEGIN(x3, 0, 100, 1)
        {
            x1 = intop(+, x1, 1);
        }
        PALLENE_INT_FOR_LOOP_END
    }
    PALLENE_INT_FOR_LOOP_END
}

/* medium cmppalleneC/loop_collapsing.pln:12 */
static void function_03(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    lua_Integer x1; /* x */
    lua_Integer x2; /* i */
    lua_Integer x3; /* j */
    lua_Integer x4;
    Table *x5;
    Table *x6;
    	
    x1 = 0;
    PALLENE_INT_FOR_LOOP_BEGIN(x2, 0, 300, 1)
    {
        PALLENE_INT_FOR_LOOP_BEGIN(x3, 0, 100, 1)
        {
            x6 = hvalue(&G->uv[0].uv);
            {
                pallene_renormalize_array(L, x6, 1, 16);
                TValue *slot = &x6->array[1 - 1];
                if (PALLENE_UNLIKELY(!ttistable(slot))) {
                    pallene_runtime_tag_check_error(L,
                        16, LUA_TTABLE, rawtt(slot),
                        "array element");
                }
                x5 = hvalue(slot);
            }
            {
                pallene_renormalize_array(L, x5, x2, 16);
                TValue *slot = &x5->array[x2 - 1];
                if (PALLENE_UNLIKELY(!ttisinteger(slot))) {
                    pallene_runtime_tag_check_error(L,
                        16, LUA_TNUMINT, rawtt(slot),
                        "array element");
                }
                x4 = ivalue(slot);
            }
            x1 = intop(+, x1, x4);
        }
        PALLENE_INT_FOR_LOOP_END
    }
    PALLENE_INT_FOR_LOOP_END
}

/* complex cmppalleneC/loop_collapsing.pln:21 */
static void function_04(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    lua_Integer x1; /* i */
    lua_Integer x2; /* j */
    Table *x3;
    Table *x4;
    	
    PALLENE_INT_FOR_LOOP_BEGIN(x1, 0, 300, 1)
    {
        PALLENE_INT_FOR_LOOP_BEGIN(x2, 0, 100, 1)
        {
            x4 = hvalue(&G->uv[0].uv);
            {
                pallene_renormalize_array(L, x4, x2, 24);
                TValue *slot = &x4->array[x2 - 1];
                if (PALLENE_UNLIKELY(!ttistable(slot))) {
                    pallene_runtime_tag_check_error(L,
                        24, LUA_TTABLE, rawtt(slot),
                        "array element");
                }
                x3 = hvalue(slot);
            }
            {
                pallene_renormalize_array(L, x3, x1, 24);
                TValue *slot = &x3->array[x1 - 1];
                setivalue(slot, 0);
            }
        }
        PALLENE_INT_FOR_LOOP_END
    }
    PALLENE_INT_FOR_LOOP_END
}

/* ------- */
/* Exports */
/* ------- */

static int function_01_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "$init", 0, nargs);
    }
    	
    function_01(L, G, L->top);
    return 0;
}

static int function_02_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "simple", 0, nargs);
    }
    	
    function_02(L, G, L->top);
    return 0;
}

static int function_03_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "medium", 0, nargs);
    }
    	
    function_03(L, G, L->top);
    return 0;
}

static int function_04_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "complex", 0, nargs);
    }
    	
    function_04(L, G, L->top);
    return 0;
}

int luaopen_cmppalleneC_loop_collapsing(lua_State *L)
{
    luaL_checkversion(L);
    	
    lua_newuserdatauv(L, 0, 1);
    int globals = lua_gettop(L);
    	
    lua_createtable(L, 4, 0);
    int closures = lua_gettop(L);
    	
    lua_newtable(L);
    int export_table = lua_gettop(L);
    	
    /* Closures */
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_01_lua, 1);
    lua_seti(L, closures, 1);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_02_lua, 1);
    lua_seti(L, closures, 2);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_03_lua, 1);
    lua_seti(L, closures, 3);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_04_lua, 1);
    lua_seti(L, closures, 4);
    	
    /* Global values */
    	
    // Run toplevel statements & initialize globals
    lua_geti(L, closures, 1);
    lua_call(L, 0, 0);
    	
    /* Exports */
    	
    lua_pushstring(L, "simple");
    lua_geti(L, closures, 2);
    lua_settable(L, export_table);
    	
    lua_pushstring(L, "medium");
    lua_geti(L, closures, 3);
    lua_settable(L, export_table);
    	
    lua_pushstring(L, "complex");
    lua_geti(L, closures, 4);
    lua_settable(L, export_table);
    	
    lua_pushvalue(L, export_table);
    return 1;
}

